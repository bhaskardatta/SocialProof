"""
CRUD Operations Module for SocialProof Backend

This module contains all database interaction functions (Create, Read, Update, Delete)
for the SocialProof application. All functions are asynchronous and use SQLAlchemy's
async session management for optimal performance with PostgreSQL.
"""

from typing import List, Optional

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app import models, schemas

# ============================================================================
# PlayerProfile CRUD Operations
# ============================================================================


async def get_player(
    db: AsyncSession, player_id: int
) -> Optional[models.PlayerProfile]:
    """
    Retrieve a single player profile by ID.

    Args:
        db: Async database session
        player_id: Unique identifier of the player to retrieve

    Returns:
        PlayerProfile object if found, None otherwise

    Example:
        player = await get_player(db, player_id=123)
        if player:
            print(f"Found player: {player.username}")
    """
    result = await db.execute(
        select(models.PlayerProfile).where(models.PlayerProfile.id == player_id)
    )
    return result.scalars().first()


async def get_player_by_email(
    db: AsyncSession, email: str
) -> Optional[models.PlayerProfile]:
    """
    Retrieve a player profile by email address.

    This function is particularly useful for checking if an email is already
    registered before creating a new player account.

    Args:
        db: Async database session
        email: Email address to search for

    Returns:
        PlayerProfile object if found, None otherwise

    Example:
        existing_player = await get_player_by_email(db, email="user@example.com")
        if existing_player:
            raise ValueError("Email already registered")
    """
    result = await db.execute(
        select(models.PlayerProfile).where(models.PlayerProfile.email == email)
    )
    return result.scalars().first()


async def get_player_by_username(
    db: AsyncSession, username: str
) -> Optional[models.PlayerProfile]:
    """
    Retrieve a player profile by username.

    Args:
        db: Async database session
        username: Username to search for

    Returns:
        PlayerProfile object if found, None otherwise

    Example:
        player = await get_player_by_username(db, username="cyber_ninja")
    """
    result = await db.execute(
        select(models.PlayerProfile).where(models.PlayerProfile.username == username)
    )
    return result.scalars().first()


async def get_players(
    db: AsyncSession, skip: int = 0, limit: int = 100
) -> List[models.PlayerProfile]:
    """
    Retrieve a list of player profiles with pagination support.

    Args:
        db: Async database session
        skip: Number of records to skip (for pagination)
        limit: Maximum number of records to return

    Returns:
        List of PlayerProfile objects

    Example:
        # Get first 10 players
        players = await get_players(db, skip=0, limit=10)

        # Get next 10 players
        players = await get_players(db, skip=10, limit=10)
    """
    result = await db.execute(select(models.PlayerProfile).offset(skip).limit(limit))
    return list(result.scalars().all())


async def create_player(
    db: AsyncSession, player: schemas.PlayerCreate
) -> models.PlayerProfile:
    """
    Create a new player profile in the database.

    This function creates a new PlayerProfile record with the provided data.
    The player_skill_rating is automatically set to the default value of 500.0,
    and the created_at timestamp is automatically generated by the database.

    Args:
        db: Async database session
        player: PlayerCreate schema containing username and email

    Returns:
        Newly created PlayerProfile object with all fields populated

    Raises:
        SQLAlchemyError: If there's a database constraint violation or error

    Example:
        new_player_data = schemas.PlayerCreate(
            username="cyber_warrior",
            email="warrior@example.com"
        )
        player = await create_player(db, new_player_data)
        print(f"Created player with ID: {player.id}")
    """
    db_player = models.PlayerProfile(
        username=player.username,
        email=player.email,
    )
    db.add(db_player)
    await db.commit()
    await db.refresh(db_player)
    return db_player


async def update_player_skill_rating(
    db: AsyncSession, player_id: int, new_rating: float
) -> Optional[models.PlayerProfile]:
    """
    Update a player's skill rating.

    Args:
        db: Async database session
        player_id: ID of the player to update
        new_rating: New skill rating value

    Returns:
        Updated PlayerProfile object if found, None otherwise

    Example:
        updated_player = await update_player_skill_rating(db, player_id=123, new_rating=650.5)
    """
    player = await get_player(db, player_id)
    if player:
        player.player_skill_rating = new_rating
        await db.commit()
        await db.refresh(player)
    return player


async def adjust_player_skill_rating(
    db: AsyncSession, player_id: int, score_change: float
) -> Optional[models.PlayerProfile]:
    """
    Adjust a player's skill rating by adding/subtracting points.

    This function is used for incremental score changes during gameplay,
    such as rewarding correct actions or penalizing mistakes.

    Args:
        db: Async database session
        player_id: ID of the player to update
        score_change: Points to add (positive) or subtract (negative)

    Returns:
        Updated PlayerProfile object if found, None otherwise

    Example:
        # Reward player for correct action
        updated_player = await adjust_player_skill_rating(db, player_id=123, score_change=25.0)

        # Penalize player for incorrect action
        updated_player = await adjust_player_skill_rating(db, player_id=123, score_change=-15.0)
    """
    player = await get_player(db, player_id)
    if player:
        player.player_skill_rating += score_change
        await db.commit()
        await db.refresh(player)
    return player


# ============================================================================
# GameScenario CRUD Operations
# ============================================================================


async def create_player_scenario(
    db: AsyncSession,
    player_id: int,
    scenario_type: str,
    content: str,
    difficulty_level: float,
    is_successful: bool = False,
) -> models.GameScenario:
    """
    Create a new game scenario for a player.

    This function will be expanded in Part 2 of the development process to include
    AI-generated content and more sophisticated scenario creation logic. For now,
    it provides the basic structure for creating scenarios.

    Args:
        db: Async database session
        player_id: ID of the player receiving the scenario
        scenario_type: Type of scenario (e.g., 'EMAIL_PHISH', 'SMS_SCAM')
        content: The actual content/text of the scenario
        difficulty_level: Numerical difficulty rating
        is_successful: Whether the player successfully completed the scenario

    Returns:
        Newly created GameScenario object

    Example:
        scenario = await create_player_scenario(
            db=db,
            player_id=123,
            scenario_type="EMAIL_PHISH",
            content="Suspicious email content...",
            difficulty_level=3.5,
            is_successful=False
        )
    """
    db_scenario = models.GameScenario(
        player_id=player_id,
        scenario_type=scenario_type,
        content=content,
        difficulty_level=difficulty_level,
        is_successful=is_successful,
    )
    db.add(db_scenario)
    await db.commit()
    await db.refresh(db_scenario)
    return db_scenario


async def get_scenario(
    db: AsyncSession, scenario_id: int
) -> Optional[models.GameScenario]:
    """
    Retrieve a single game scenario by ID.

    Args:
        db: Async database session
        scenario_id: Unique identifier of the scenario

    Returns:
        GameScenario object if found, None otherwise
    """
    result = await db.execute(
        select(models.GameScenario).where(models.GameScenario.id == scenario_id)
    )
    return result.scalars().first()


async def get_player_scenarios(
    db: AsyncSession, player_id: int, skip: int = 0, limit: int = 100
) -> List[models.GameScenario]:
    """
    Retrieve all scenarios for a specific player with pagination.

    Args:
        db: Async database session
        player_id: ID of the player whose scenarios to retrieve
        skip: Number of records to skip (for pagination)
        limit: Maximum number of records to return

    Returns:
        List of GameScenario objects for the specified player

    Example:
        scenarios = await get_player_scenarios(db, player_id=123, skip=0, limit=10)
    """
    result = await db.execute(
        select(models.GameScenario)
        .where(models.GameScenario.player_id == player_id)
        .offset(skip)
        .limit(limit)
    )
    return list(result.scalars().all())


async def update_scenario_result(
    db: AsyncSession, scenario_id: int, is_successful: bool
) -> Optional[models.GameScenario]:
    """
    Update the success status of a game scenario.

    This function is used to record whether a player successfully identified
    and handled a security threat in a given scenario.

    Args:
        db: Async database session
        scenario_id: ID of the scenario to update
        is_successful: Whether the player was successful

    Returns:
        Updated GameScenario object if found, None otherwise

    Example:
        updated_scenario = await update_scenario_result(db, scenario_id=456, is_successful=True)
    """
    scenario = await get_scenario(db, scenario_id)
    if scenario:
        scenario.is_successful = is_successful
        await db.commit()
        await db.refresh(scenario)
    return scenario


# ============================================================================
# AI-Powered Scenario CRUD Operations - Part 2
# ============================================================================


async def create_ai_generated_scenario(
    db: AsyncSession, player_id: int, scenario_type: str, ai_result: dict
) -> models.GameScenario:
    """
    Create a game scenario with AI-generated content.

    This function stores a scenario that was generated by the AI system,
    including the content, difficulty level, and generation metadata.

    Args:
        db: Async database session
        player_id: ID of the player receiving the scenario
        scenario_type: Type of scenario (e.g., 'EMAIL_PHISH', 'SMS_SCAM')
        ai_result: Dictionary containing AI generation results with keys:
                   - content: Generated scenario text
                   - difficulty_level: Numerical difficulty (0-10)
                   - difficulty_label: Human-readable difficulty

    Returns:
        Newly created GameScenario object with all fields populated

    Example:
        from app import ai_core
        ai_result = ai_core.generate_scenario_content(650, "EMAIL_PHISH")
        scenario = await create_ai_generated_scenario(
            db=db,
            player_id=123,
            scenario_type="EMAIL_PHISH",
            ai_result=ai_result
        )
    """
    db_scenario = models.GameScenario(
        player_id=player_id,
        scenario_type=scenario_type,
        content=ai_result["content"],
        difficulty_level=ai_result["difficulty_level"],
        is_successful=False,  # Not yet attempted
    )
    db.add(db_scenario)
    await db.commit()
    await db.refresh(db_scenario)
    return db_scenario


# ============================================================================
# Player Statistics CRUD Operations - Performance Tracking
# ============================================================================


async def get_player_stats(db: AsyncSession, player_id: int) -> dict:
    """
    Calculate and return comprehensive statistics for a player.

    This function analyzes all of a player's completed scenarios to calculate
    performance metrics including accuracy, correct identifications, and mistakes.

    NOTE: This is a simplified implementation that calculates stats based on
    the is_successful field. For more detailed tracking, you could add an
    'is_resolved' boolean field and action tracking to the GameScenario model.

    Args:
        db: Async database session
        player_id: ID of the player whose stats to calculate

    Returns:
        Dictionary containing player statistics

    Example:
        stats = await get_player_stats(db, player_id=123)
        print(f"Accuracy: {stats['accuracy_percentage']}%")
    """

    # Get player to ensure they exist and get current rating
    player = await get_player(db, player_id=player_id)
    if not player:
        return {
            "total_scenarios_resolved": 0,
            "correctly_identified_phish": 0,
            "missed_phish": 0,
            "incorrectly_reported_safe": 0,
            "accuracy_percentage": 0.0,
            "current_skill_rating": 500.0,
        }

    # Get all scenarios for the player
    scenarios = await get_player_scenarios(db, player_id=player_id, skip=0, limit=1000)

    # Calculate statistics
    total_resolved = len(scenarios)
    correct_count = sum(1 for s in scenarios if s.is_successful)
    incorrect_count = total_resolved - correct_count

    # For phishing detection, we'll estimate based on scenario types
    phishing_scenarios = [
        s
        for s in scenarios
        if "phish" in s.scenario_type.lower() or "smish" in s.scenario_type.lower()
    ]
    correctly_identified = sum(1 for s in phishing_scenarios if s.is_successful)
    missed_phish = len(phishing_scenarios) - correctly_identified

    # False positives (incorrectly reported safe messages)
    incorrectly_reported_safe = (
        incorrect_count - missed_phish if incorrect_count > missed_phish else 0
    )

    # Calculate accuracy percentage
    accuracy = (correct_count / total_resolved * 100) if total_resolved > 0 else 0.0

    stats = {
        "total_scenarios_resolved": total_resolved,
        "correctly_identified_phish": correctly_identified,
        "missed_phish": missed_phish,
        "incorrectly_reported_safe": incorrectly_reported_safe,
        "accuracy_percentage": round(accuracy, 1),
        "current_skill_rating": player.player_skill_rating,
    }

    return stats
